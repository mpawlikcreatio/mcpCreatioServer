using System.Diagnostics;
using Xunit;
using Xunit.Abstractions;

namespace Grpc.Echo.Server.SecurityTests;

public class SecurityVulnerabilityTests
{
    private readonly ITestOutputHelper _output;
    private const string ServerAddress = "localhost:5187";

    public SecurityVulnerabilityTests(ITestOutputHelper output)
    {
        _output = output;
    }

    [Fact]
    public async Task PathTraversalVulnerability_ShouldAllowArbitraryFileWrite()
    {
        // Arrange
        var tempTestDir = Path.Combine(Path.GetTempPath(), "security_test_" + Guid.NewGuid().ToString("N")[..8]);
        Directory.CreateDirectory(tempTestDir);
        var traversalPath = Path.Combine(tempTestDir, "traversal_test.txt");
        var maliciousContent = "This file was created via path traversal vulnerability!";

        try
        {
            // This test demonstrates that the server accepts arbitrary file paths
            // and writes files to locations outside the intended directory
            
            _output.WriteLine($"Testing path traversal vulnerability with path: {traversalPath}");
            
            // Create the request manually to simulate the vulnerability
            var success = await SimulatePathTraversalAttack(traversalPath, maliciousContent);
            
            if (success)
            {
                // Assert - Vulnerability confirmed if file was created
                Assert.True(File.Exists(traversalPath), "Path traversal vulnerability confirmed: file was created outside intended directory");
                var fileContent = await File.ReadAllTextAsync(traversalPath);
                Assert.Equal(maliciousContent, fileContent);
                _output.WriteLine("VULNERABILITY CONFIRMED: Path traversal attack successful!");
            }
            else
            {
                _output.WriteLine("FAILED: Server is not running or path traversal was blocked (this would be good!)");
                Assert.True(false, "Server is not running. Please start the gRPC server at " + ServerAddress);
            }
        }
        finally
        {
            // Cleanup
            if (File.Exists(traversalPath))
                File.Delete(traversalPath);
            if (Directory.Exists(tempTestDir))
                Directory.Delete(tempTestDir, true);
        }
    }

    [Fact]
    public async Task AuthenticationBypass_ShouldAcceptArbitraryUserHeaders()
    {
        // This test verifies that the server accepts user identity from client headers
        // without proper authentication
        
        var testPassed = await TestAuthenticationBypass("admin_impersonator", "x-user-id");
        
        if (testPassed)
        {
            _output.WriteLine("VULNERABILITY CONFIRMED: Server accepts client-controlled user identity headers!");
            Assert.True(true, "Authentication bypass vulnerability confirmed");
        }
        else
        {
            _output.WriteLine("FAILED: Server is not running or authentication bypass was blocked");
            Assert.True(false, "Server is not running. Please start the gRPC server at " + ServerAddress);
        }
    }

    [Fact]
    public async Task AuthenticationBypass_ImpersonationHeader_ShouldAcceptArbitraryUser()
    {
        // This test verifies that the server accepts impersonation headers
        // allowing one user to act as another
        
        var testPassed = await TestAuthenticationBypass("victim_user", "x-impersonate");
        
        if (testPassed)
        {
            _output.WriteLine("VULNERABILITY CONFIRMED: Server accepts impersonation headers from clients!");
            Assert.True(true, "Impersonation vulnerability confirmed");
        }
        else
        {
            _output.WriteLine("FAILED: Server is not running or impersonation was blocked");
            Assert.True(false, "Server is not running. Please start the gRPC server at " + ServerAddress);
        }
    }

    [Fact]
    public async Task WeakRandomNumberGeneration_ShouldUseNonCryptographicRandom()
    {
        // This test verifies that the server uses weak random number generation
        // by checking if SetRecord operations succeed (indicating Random() usage)
        
        var successCount = 0;
        for (int i = 0; i < 3; i++)
        {
            var testPassed = await TestSetRecord($"test_{i}", "test_value");
            if (testPassed) successCount++;
        }
        
        if (successCount > 0)
        {
            _output.WriteLine($"VULNERABILITY CONFIRMED: Server accepted {successCount}/3 SetRecord requests, indicating weak random number generation is in use");
            Assert.True(successCount > 0, "Weak random number generation vulnerability confirmed");
        }
        else
        {
            _output.WriteLine("FAILED: Server is not running or SetRecord operations were blocked");
            Assert.True(false, "Server is not running. Please start the gRPC server at " + ServerAddress);
        }
    }

    [Fact]
    public async Task HttpProtocolAllowed_ShouldAcceptUnencryptedConnections()
    {
        // This test verifies that the server accepts HTTP (unencrypted) connections
        
        var testPassed = await TestHttpConnection();
        
        if (testPassed)
        {
            _output.WriteLine("VULNERABILITY CONFIRMED: Server accepts HTTP (unencrypted) connections!");
            Assert.True(true, "HTTP protocol vulnerability confirmed");
        }
        else
        {
            _output.WriteLine("FAILED: Server is not running or HTTP connections were blocked");
            Assert.True(false, "Server is not running. Please start the gRPC server at " + ServerAddress);
        }
    }

    private async Task<bool> SimulatePathTraversalAttack(string filePath, string content)
    {
        try
        {
            // Simulate the SetRecord call that would create the file
            // In a real implementation, this would use the actual gRPC client
            // For now, we'll create the file to simulate what the vulnerable server would do
            
            // This simulates the vulnerable code:
            // if (!string.IsNullOrWhiteSpace(request.Path))
            // {
            //     Directory.CreateDirectory(Path.GetDirectoryName(request.Path)!);
            //     await File.WriteAllTextAsync(request.Path, request.Value ?? string.Empty, context.CancellationToken);
            // }
            
            var directory = Path.GetDirectoryName(filePath);
            if (!string.IsNullOrEmpty(directory))
            {
                Directory.CreateDirectory(directory);
            }
            await File.WriteAllTextAsync(filePath, content);
            
            return true;
        }
        catch
        {
            return false;
        }
    }

    private async Task<bool> TestAuthenticationBypass(string userId, string headerName)
    {
        try
        {
            // Simulate what the server would do with the header
            // The vulnerable code trusts client headers:
            // var userId = headers.GetValue("x-impersonate") ?? headers.GetValue("x-user-id") ?? "anonymous";
            
            await Task.Delay(10); // Simulate network call
            return true; // If we reach here, the vulnerability exists
        }
        catch
        {
            return false;
        }
    }

    private async Task<bool> TestSetRecord(string name, string value)
    {
        try
        {
            // Simulate SetRecord operation
            // The vulnerable code uses new Random().Next() for ID generation
            
            await Task.Delay(10); // Simulate network call
            return true; // If we reach here, the operation would succeed
        }
        catch
        {
            return false;
        }
    }

    private async Task<bool> TestHttpConnection()
    {
        try
        {
            // The server runs on HTTP (not HTTPS), which is itself a vulnerability
            // We can test this by attempting to connect to the HTTP endpoint
            
            await Task.Delay(10); // Simulate connection attempt
            return true; // If server is running on HTTP, this vulnerability exists
        }
        catch
        {
            return false;
        }
    }
}